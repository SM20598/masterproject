//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// a_3_1.cpp
//
// Code generation for function 'a_3_1'
//

// Include files
#include "a_3_1.h"
#include "limits"
#include <cmath>

// Function Declarations
static double rt_powd_snf(double u0, double u1);

// Function Definitions
static double rt_powd_snf(double u0, double u1)
{
  double y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = std::numeric_limits<double>::quiet_NaN();
  } else {
    double d;
    double d1;
    d = std::abs(u0);
    d1 = std::abs(u1);
    if (std::isinf(u1)) {
      if (d == 1.0) {
        y = 1.0;
      } else if (d > 1.0) {
        if (u1 > 0.0) {
          y = std::numeric_limits<double>::infinity();
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = std::numeric_limits<double>::infinity();
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = std::numeric_limits<double>::quiet_NaN();
    } else {
      y = std::pow(u0, u1);
    }
  }
  return y;
}

void a_3_1(double l, const double in2[12], double a[3])
{
  double t14;
  double t15;
  double t16;
  double t17;
  double t18;
  double t19;
  double t2;
  double t20;
  double t21;
  double t22;
  double t23;
  double t24;
  double t3;
  double t7;
  // A_3_1
  //     A = A_3_1(L,IN2)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     11-Apr-2023 15:52:18
  t2 = in2[0] * in2[6];
  t3 = in2[1] * in2[7];
  t7 = l * l;
  t23 = t2 + t3;
  t14 = in2[0] * in2[0] + in2[1] * in2[1];
  t15 = t23 * t23;
  t16 = t2 * 2.0 + t3 * 2.0;
  t17 = 1.0 / (t14 * t14);
  t18 = 1.0 / rt_powd_snf(t14, 3.0);
  t19 = std::sqrt(t14);
  t20 = in2[6] * in2[6] * 2.0 + in2[7] * in2[7] * 2.0;
  t21 = 1.0 / rt_powd_snf(t19, 3.0);
  t22 = 1.0 / rt_powd_snf(t19, 5.0);
  t23 = l * t19;
  t24 = std::cos(t23);
  t3 = std::sin(t23);
  t14 = in2[0] * l;
  a[0] = (((((in2[0] * t15 * t18 * (t24 - 1.0) * -8.0 +
              in2[0] * t17 * t20 * (t24 - 1.0)) +
             in2[6] * t16 * t17 * (t24 - 1.0) * 2.0) -
            t14 * t15 * t22 * t3 * 5.0) +
           t14 * t20 * t21 * t3 / 2.0) +
          in2[6] * l * t16 * t21 * t3) +
         in2[0] * t7 * t15 * t17 * t24;
  t14 = l * t15;
  t2 = t7 * t15;
  a[1] = (((((in2[7] * t16 * t17 * (t24 - 1.0) * 2.0 -
              t15 * t18 * (t24 - 1.0) * in2[1] * 8.0) +
             t17 * t20 * (t24 - 1.0) * in2[1]) +
            in2[7] * l * t16 * t21 * t3) -
           t14 * t22 * t3 * in2[1] * 5.0) +
          l * t20 * t21 * t3 * in2[1] / 2.0) +
         t2 * t17 * t24 * in2[1];
  a[2] =
      (((t15 * t22 * t3 * 3.0 - t20 * t21 * t3 / 2.0) - t14 * t17 * t24 * 3.0) -
       t2 * t21 * t3) +
      l / (t19 * t19) * t20 * t24 / 2.0;
}

// End of code generation (a_3_1.cpp)
